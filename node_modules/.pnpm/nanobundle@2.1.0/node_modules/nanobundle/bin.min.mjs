#!/usr/bin/env node
import{parse as nr,TSConfckParseError as Ft}from"tsconfck";import Bt from"string-dedent";import Dt from"meow";var Be=Dt(`
Usage
  $ nanobundle <command> [options]

Available Commands
  build    Build once and exit
  clean    Remove outputs

Options
  --version            Display current version

  --cwd                Use an alternative working directory

  --clean              Clean outputs before build

  --tsconfig           Specify the path to a custom tsconfig.json

  --import-maps        Specify import map file path (default: package.json)

  --root-dir           Specify the path to resolve source entry (default: ./src)
                       This also can be configured by tsconfig.json

  --out-dir            Specify the path to resolve source entry (default: ./lib)
                       This also can be configured by tsconfig.json

  --platform           DEPRECATED. Specify bundle target platform (default: "netural")
                       One of "netural", "browser", "node" is allowed

  --standalone         Embed external dependencies into the bundle (default: false)

  --external           Specify external dependencies to exclude from the bundle

  --jsx                Specify JSX mode. One of "transform", "preserve", "automatic" is allowed
                       This also can be configured by tsconfig.json

  --jsx-factory        Specify JSX factory (default: "React.createElement")
                       This also can be configured by tsconfig.json

  --jsx-fragment       Specify JSX <Fragment> factory (default: "Fragment")
                       This also can be configured by tsconfig.json

  --jsx-import-source  Specify JSX import source (default: "react")
                       This also can be configured by tsconfig.json

  --no-sourcemap       Disable source map generation

  --no-legal-comments  Disable legal comments generation

  --no-bundle          Disable ESBuild bundle and other files build

  --no-dts             Disable TypeScript .d.ts build

  --verbose            Set to report build result more verbosely

  --help               Display this message
`,{importMeta:import.meta,flags:{cwd:{type:"string",default:process.cwd()},clean:{type:"boolean",default:!1},rootDir:{type:"string"},outDir:{type:"string"},tsconfig:{type:"string",default:"tsconfig.json"},importMaps:{type:"string",default:"package.json"},external:{type:"string",isMultiple:!0,default:[]},platform:{type:"string"},standalone:{type:"boolean",default:!1},sourcemap:{type:"boolean",default:!0},legalComments:{type:"boolean",default:!0},bundle:{type:"boolean",default:!0},dts:{type:"boolean",default:!0},jsx:{type:"string"},jsxFactory:{type:"string"},jsxFragment:{type:"string"},jsxImportSource:{type:"string"},verbose:{type:"boolean",default:!1}}});import{formatWithOptions as se}from"node:util";import le from"kleur";import{formatWithOptions as qe}from"node:util";import q from"kleur";var{FORCE_COLOR:ze,NODE_DISABLE_COLORS:St,NO_COLOR:Nt,TERM:Rt}=process.env,It=process.stdout.isTTY,te=!St&&Nt==null&&Rt!=="dumb"&&(ze!=null&&ze!=="0"||It);function re(e,t){let s="  ".repeat(t);return e.split(`
`).map(r=>`${s}${r}`).join(`
`)}function Ue(e,...t){return qe({colors:te},e,...t)}function ie(e){return q.underline().cyan(e)}function x(e){return q.underline().cyan(e)}function H(e){return e==null?q.bold().green(`${e}`):typeof e=="string"?q.green(`'${e}'`):typeof e!="object"?q.green(`${e}`):oe(e)}function b(e){return q.bold().blue(`"${e}"`)}function oe(e){let t=qe({colors:te},"%o",e);return q.white(t)}function G(e){return q.bold().blue(`\`${e}\``)}function he(e){return q.bold().cyan(e)}var F=class extends Error{},ae=class extends F{};var Ee=class e{#r;#e;color=te;level="debug";constructor(t,o=0){this.#r=o,this.#e=t}#t(t){return re(t,this.#r)}debug(t,...o){if(this.level!=="debug")return;let s=se({colors:this.color},t,...o),r=this.#t(s);this.#e.debug(le.gray(`[debug] ${r}`))}info(t,...o){let s=se({colors:this.color},t,...o),r=this.#t(s);this.#e.info(le.white(`[info] ${r}`))}warn(t,...o){let s=se({colors:this.color},t,...o),r=this.#t(s);this.#e.warn(le.yellow(`[warn] ${r}`))}error(t,...o){let s=se({colors:this.color},t,...o),r=this.#t(s);this.#e.error(le.red(`[error] ${r}`))}captureException(t){let o;t instanceof F&&t.message?o=t.message:t instanceof Error?o=se({colors:this.color},t.stack):o=se({colors:this.color},"%s",t);let s=this.#t(o);this.#e.error(le.bold().red(`${s}`))}createChildReporter(){let t=new e(this.#e,this.#r+1);return t.color=this.color,t}};import Mt from"browserslist";import He from"semver";var Ke={chrome:"chrome",firefox:"firefox",safari:"safari",edge:"edge",ios_saf:"ios",android:"chrome",and_chr:"chrome",and_ff:"firefox"},Pt=new Set(Object.keys(Ke));function _t(e){return Pt.has(e)}function Qe(e){var r,k,a,n;let t=Mt(e==null?void 0:e.query,{path:e==null?void 0:e.basePath}),o=new Map;for(let l of t){let[m,u]=l.split(" ");if(!_t(m))continue;let i=Ke[m],c=+u.split("-")[0];if(m==="android")if(c>4.4)i="chrome",c=96;else continue;let g=o.get(i);(!g||g>c)&&o.set(i,c)}let s=Array.from(o.entries()).map(l=>l.join(""));if((k=(r=e==null?void 0:e.manifest)==null?void 0:r.engines)!=null&&k.node){let l=He.minVersion(e.manifest.engines.node);l&&s.push("node"+l.format())}else s.push("node18");if((n=(a=e==null?void 0:e.manifest)==null?void 0:a.engines)!=null&&n.deno){let l=He.minVersion(e.manifest.engines.deno);l&&s.push("deno"+l.format())}else s.push("deno1.9");return s}import*as Ze from"node:path";import*as et from"node:fs/promises";var tt=async({basePath:e})=>{let t=Ze.resolve(e,"package.json"),{publishConfig:o,...s}=await et.readFile(t,"utf-8").then(JSON.parse);return{...s,...o}};import*as ne from"node:path";import At from"string-dedent";var pe=class extends F{name="NanobundleConfigError"};function rt({flags:e,manifest:t,targets:o,reporter:s,tsconfig:r,tsconfigPath:k}){var d,h,v,D,N,U,O,C,P,E,$,p,z;let a=ne.resolve(e.cwd),n=(...f)=>ne.resolve(a,...f),l=(f,be=!1)=>{let ee=ne.relative(a,f);return be?`./${ee}`:ee},m=e.bundle,u=e.verbose,i=e.legalComments,c=e.standalone,g=k,B=ne.resolve(a,e.importMaps),T=e.external,I=[...t.dependencies?Object.keys(t.dependencies):[],...t.peerDependencies?Object.keys(t.peerDependencies):[],...T],w=e.rootDir||((d=r==null?void 0:r.compilerOptions)==null?void 0:d.rootDir)||"src",j=e.outDir||((h=r==null?void 0:r.compilerOptions)==null?void 0:h.outDir)||"lib",Y=t.type==="module"?"esmodule":"commonjs",R=!0;((v=r==null?void 0:r.compilerOptions)==null?void 0:v.sourceMap)!=null&&(R=r.compilerOptions.sourceMap),e.sourcemap===!1&&(R=!1),e.platform&&s.warn(`${H("--platform")} flag is deprecated, and will be removed next major update.`);let y="neutral";["node","deno","browser"].includes(e.platform||"")?y=e.platform:(D=t.engines)!=null&&D.node?y="node":(N=t.engines)!=null&&N.deno&&(y="deno");let M=!1;if(e.dts&&r&&(M=((U=r.compilerOptions)==null?void 0:U.declaration)!==!1),!M&&w===j)throw new pe(At`
      ${b("rootDir")} (${x(w)}) and ${b("outDir")} (${x(j)}) are conflict!

      Please specify different directory for one of them.
    `);let X;((O=r==null?void 0:r.compilerOptions)==null?void 0:O.jsx)==="preserve"&&(X="preserve"),["react","react-native"].includes((C=r==null?void 0:r.compilerOptions)==null?void 0:C.jsx)&&(X="transform"),["react-jsx","react-jsxdev"].includes((P=r==null?void 0:r.compilerOptions)==null?void 0:P.jsx)&&(X="automatic"),e.jsx==="preserve"&&(X="preserve"),e.jsx==="transform"&&(X="transform"),e.jsx==="automatic"&&(X="automatic");let ye=!1;!e.jsx&&((E=r==null?void 0:r.compilerOptions)==null?void 0:E.jsx)==="react-jsxdev"&&(ye=!0);let ge=e.jsxFactory||(($=r==null?void 0:r.compilerOptions)==null?void 0:$.jsxFactory)||"React.createElement",L=e.jsxFragment||((p=r==null?void 0:r.compilerOptions)==null?void 0:p.jsxFragmentFactory)||"Fragment",Je=e.jsxImportSource||((z=r==null?void 0:r.compilerOptions)==null?void 0:z.jsxImportSource)||"react";return{cwd:a,verbose:u,module:Y,platform:y,sourcemap:R,legalComments:i,bundle:m,declaration:M,jsx:X,jsxDev:ye,jsxFactory:ge,jsxFragment:L,jsxImportSource:Je,standalone:c,rootDir:w,outDir:j,tsconfigPath:g,importMapsPath:B,externalDependencies:I,forceExternalDependencies:T,manifest:t,targets:o,reporter:s,resolvePath:n,resolveRelativePath:l}}import*as Q from"node:path";import _ from"string-dedent";import ot from"kleur";var st=({context:e,reporter:t})=>{let{cwd:r,rootDir:k,outDir:a,sourcemap:n,manifest:l,tsconfigPath:m,jsx:u,platform:i,module:c}=e,g={commonjs:"commonjs",esmodule:"esmodule",css:void 0,dts:void 0,file:void 0}[c],B=e.resolvePath(k),T=e.resolvePath(a),I=u!=null,w=m!=null,j=!(w&&B===T),Y=e.jsx==="preserve",R=new Map;function y(d){var Xe;let{key:h,parentKey:v,sourcemap:D,entryPath:N,platform:U,module:O,mode:C,preferredModule:P,customConditions:E}=d;if(!N.startsWith("./"))throw new W(A.INVALID_PATH_KEY(h));if(N.includes("*"))throw new W(A.SUBPATH_PATTERN(N));if(O==="dts"&&!/\.d\.(c|m)?ts$/.test(N))throw new W(A.INVALID_DTS_FORMAT());let $=R.get(N);if($){if($.key.startsWith("exports")&&!h.startsWith("exports")){($.platform!==U||$.module!==O)&&t.warn(A.PRECEDENSE_ENTRY($,d));return}if($.platform!==U||$.module!==O){let S="";throw($.key==="main"&&h==="module"||$.key==="module"&&h==="main")&&(S=_`
            Did you forgot to set ${b("type")} to ${H("module")} for ESM-first approach?
          `),$.module===O&&$.platform!==U&&(S=_`
            Did you forget to specify the Node.js version in the ${b("engines")} field?
            Or you may not need to specify ${b("require")} or ${b("node")} entries.
          `),new W(A.CONFLICT_ENTRY($,d,S))}return}let p=new Set,z=e.resolvePath(N),f=z.replace(T,B),be=/\.min(?<ext>\.(m|c)?jsx?)$/,ee=f.match(be),Ut=!!ee,Ge=(Xe=ee==null?void 0:ee.groups)==null?void 0:Xe.ext;if(Ge&&(f=f.replace(be,Ge)),!/jsx?$/.test(f))switch(O){case"commonjs":{w&&p.add(`${f}.cts`),j&&p.add(`${f}.cjs`),I&&w&&p.add(`${f}.tsx`),w&&p.add(`${f}.ts`),I&&j&&p.add(`${f}.jsx`),j&&p.add(`${f}.js`);break}case"esmodule":{w&&p.add(`${f}.mts`),j&&p.add(`${f}.mjs`),I&&w&&p.add(`${f}.tsx`),w&&p.add(`${f}.ts`),I&&j&&p.add(`${f}.jsx`),j&&p.add(`${f}.js`);break}}switch(O){case"commonjs":{if(w&&p.add(f.replace(/\.c?jsx?$/,".cts")),j&&p.add(f.replace(/\.c?jsx?$/,".cjs")),I&&w&&p.add(f.replace(/\.c?jsx?$/,".tsx")),w&&p.add(f.replace(/\.c?jsx?$/,".ts")),I&&j&&p.add(f.replace(/\.c?jsx?$/,".jsx")),j&&p.add(f.replace(/\.c?jsx?$/,".js")),v){let S=f.replace("."+v,"");w&&p.add(S.replace(/\.c?jsx?$/,".cts")),j&&p.add(S.replace(/\.c?jsx?$/,".cjs")),I&&w&&p.add(S.replace(/\.c?jsx?$/,".tsx")),w&&p.add(S.replace(/\.c?jsx?$/,".ts")),I&&j&&p.add(S.replace(/\.c?jsx?$/,".jsx")),j&&p.add(S.replace(/\.c?jsx?$/,".js"))}j&&p.add(f);break}case"esmodule":{if(w&&p.add(f.replace(/\.m?jsx?$/,".mts")),j&&p.add(f.replace(/\.m?jsx?$/,".mjs")),I&&w&&p.add(f.replace(/\.m?jsx?$/,".tsx")),w&&p.add(f.replace(/\.m?jsx?$/,".ts")),I&&j&&p.add(f.replace(/\.m?jsx?$/,".jsx")),j&&p.add(f.replace(/\.m?jsx?$/,".js")),v){let S=f.replace("."+v,"");w&&p.add(S.replace(/\.m?jsx?$/,".mts")),j&&p.add(S.replace(/\.m?jsx?$/,".mjs")),I&&w&&p.add(S.replace(/\.m?jsx?$/,".tsx")),w&&p.add(S.replace(/\.m?jsx?$/,".ts")),I&&j&&p.add(S.replace(/\.m?jsx?$/,".jsx")),j&&p.add(S.replace(/\.m?jsx?$/,".js"))}j&&p.add(f);break}case"css":{p.add(f);break}case"dts":{let S=/\.d\.(c|m)ts$/,K,Fe=".ts";if(!w)break;P==="commonjs"?(K=/\.d\.(c?)ts$/,Fe=".cts"):P==="esmodule"&&(K=/\.d\.(m?)ts$/,Fe=".mts"),K!=null&&K.test(f)?p.add(f.replace(K,Fe)):S.test(f)&&p.add(f.replace(S,".$1ts")),I&&p.add(f.replace(/\.d\.(m|c)?ts$/,".tsx")),p.add(f.replace(/\.d\.(m|c)?ts$/,".ts"));break}case"file":{Q.relative(r,Q.dirname(z))?p.add(f):p.add(z);break}}let Ye=[...p];I&&Ye.sort((S,K)=>S.endsWith("x")&&K.endsWith("x")?0:S.endsWith("x")?-1:1),R.set(N,{key:h,entryPath:N,mode:C,minify:Ut,sourcemap:D,platform:U,module:O,sourceFile:Ye,outputFile:z,customConditions:E})}function M({key:d,entryPath:h}){switch(Q.extname(h)){case".cjs":{y({key:d,sourcemap:n,platform:i,mode:void 0,module:"commonjs",preferredModule:"commonjs",entryPath:h,customConditions:[]});break}case".mjs":{y({key:d,sourcemap:n,platform:i,mode:void 0,module:"esmodule",preferredModule:"esmodule",entryPath:h,customConditions:[]});break}case".node":{y({key:d,sourcemap:n,platform:"node",mode:void 0,module:"file",entryPath:h,customConditions:[]});break}case".json":{y({key:d,sourcemap:n,platform:i,mode:void 0,module:"file",entryPath:h,customConditions:[]});break}case".jsx":Y||t.warn(A.NO_NEED_JSX(h));default:{y({key:d,sourcemap:n,platform:i,mode:void 0,module:c,entryPath:h,customConditions:[]});break}}}function X({key:d,entryPath:h}){if(/\.m?jsx?$/.test(h))y({key:d,sourcemap:n,platform:i,mode:void 0,module:"esmodule",preferredModule:"esmodule",entryPath:h,customConditions:[]});else throw new W(A.INVALID_MODULE_EXTENSION())}function ye({key:d,entryPath:h}){if(/\.d\.(m|c)?ts$/.test(h))y({key:d,sourcemap:n,platform:i,mode:void 0,module:"dts",preferredModule:g,entryPath:h,customConditions:[]});else throw new W(A.INVALID_TYPES_EXTENSION())}function ge({key:d,entryPath:h}){switch(Q.extname(h)){case".js":{y({key:d,sourcemap:!1,platform:"node",mode:void 0,module:c,preferredModule:g,entryPath:h,customConditions:[]});break}case".cjs":{y({key:d,sourcemap:!1,platform:"node",mode:void 0,module:"commonjs",preferredModule:g,entryPath:h,customConditions:[]});break}case".mjs":{y({key:d,sourcemap:!1,platform:"node",mode:void 0,module:"esmodule",preferredModule:g,entryPath:h,customConditions:[]});break}default:throw new W(A.INVALID_BIN_EXTENSION())}}function L({key:d,parentKey:h,platform:v,mode:D,module:N,preferredModule:U,entryPath:O,customConditions:C}){if(typeof O=="string"){if(h==="types"){y({key:d,parentKey:h,sourcemap:n,platform:v,mode:D,module:"dts",preferredModule:U,entryPath:O,customConditions:C});return}switch(Q.extname(O)){case".cjs":{y({key:d,parentKey:h,sourcemap:n,platform:v,mode:D,module:"commonjs",preferredModule:"commonjs",entryPath:O,customConditions:C});break}case".mjs":{y({key:d,parentKey:h,sourcemap:n,platform:v,mode:D,module:"esmodule",preferredModule:"esmodule",entryPath:O,customConditions:C});break}case".node":{y({key:d,parentKey:h,sourcemap:n,platform:"node",mode:D,module:"file",preferredModule:U,entryPath:O,customConditions:C});break}case".json":{y({key:d,parentKey:h,sourcemap:n,platform:v,mode:D,module:"file",preferredModule:U,entryPath:O,customConditions:C});break}case".css":{y({key:d,parentKey:h,sourcemap:n,platform:v,mode:D,module:"css",preferredModule:U,entryPath:O,customConditions:C});break}case".jsx":Y||t.warn(A.NO_NEED_JSX(O));default:{y({key:d,parentKey:h,sourcemap:n,platform:v,mode:D,module:N,preferredModule:U,entryPath:O,customConditions:C});break}}}else if(typeof O=="object"){if(h==="types")throw new W(A.INVALID_DTS_FORMAT());let P=Object.entries(O);if(typeof O.types<"u"){if(P.findIndex($=>$[0]==="types")!==0)throw new W(A.INVALID_DTS_ORDER())}else{let E=P.find(([p,z])=>typeof z=="string"&&!p.startsWith("."));if(w&&E!==void 0)if(typeof O.default=="string")P=[["types$implicit",xe(O.default)],...P];else{if(typeof O.require=="string"&&typeof O.import=="string")throw new W(A.UNDETEMINED_DTS_SOURCE(d,O.require,O.import));typeof O.require=="string"?P=[["types$implicit",xe(O.require)],...P]:typeof O.import=="string"?P=[["types$implicit",xe(O.import)],...P]:U?P=[["types$implicit",xe(E[1])],...P]:t.warn(A.TYPES_MAY_NOT_BE_RESOLVED(d))}}for(let[E,$]of P)switch(E){case"import":{L({key:`${d}.${E}`,parentKey:E,platform:v,mode:D,module:"esmodule",preferredModule:"esmodule",entryPath:$,customConditions:C});break}case"require":{L({key:`${d}.${E}`,parentKey:E,platform:v,mode:D,module:"commonjs",preferredModule:"commonjs",entryPath:$,customConditions:C});break}case"types":{L({key:`${d}.${E}`,parentKey:E,platform:v,mode:D,module:"dts",preferredModule:void 0,entryPath:$,customConditions:C});break}case"types$implicit":{L({key:`${d}.types`,parentKey:E,platform:v,mode:D,module:"dts",preferredModule:U,entryPath:$,customConditions:C});break}case"node":{L({key:`${d}.${E}`,parentKey:E,platform:"node",mode:D,module:N,preferredModule:U,entryPath:$,customConditions:C});break}case"deno":{L({key:`${d}.${E}`,parentKey:E,platform:"deno",mode:D,module:N,preferredModule:U,entryPath:$,customConditions:C});break}case"browser":{L({key:`${d}.${E}`,parentKey:E,platform:"browser",mode:D,module:N,preferredModule:U,entryPath:$,customConditions:C});break}case"development":{L({key:`${d}.${E}`,parentKey:E,platform:v,mode:"development",module:N,preferredModule:U,entryPath:$,customConditions:C});break}case"production":{L({key:`${d}.${E}`,parentKey:E,platform:v,mode:"production",module:N,preferredModule:U,entryPath:$,customConditions:C});break}case"default":{L({key:`${d}.${E}`,parentKey:E,platform:v,mode:D,module:N,preferredModule:U,entryPath:$,customConditions:C});break}case".":{L({key:`${d}["${E}"]`,parentKey:E,platform:v,mode:D,module:N,preferredModule:U,entryPath:$,customConditions:C});break}default:{E.startsWith("./")?L({key:`${d}["${E}"]`,parentKey:E,platform:v,mode:D,module:N,preferredModule:U,entryPath:$,customConditions:C}):(t.warn(A.CUSTOM_CONDITION(E)),L({key:`${d}.${E}`,parentKey:E,platform:v,mode:D,module:N,preferredModule:U,entryPath:$,customConditions:[...new Set([...C,E])]}));break}}}}if(l.exports?L({key:"exports",parentKey:"exports",platform:i,mode:void 0,module:c,preferredModule:g,entryPath:l.exports,customConditions:[]}):(l.main||l.module)&&t.warn(A.RECOMMEND_EXPORTS()),typeof l.main=="string"&&M({key:"main",entryPath:l.main}),typeof l.module=="string"&&(X({key:"module",entryPath:l.module}),t.warn(A.MODULE_NOT_RECOMMENDED())),typeof l.types=="string"&&ye({key:"types",entryPath:l.types}),typeof l.bin=="string"&&ge({key:"bin",entryPath:l.bin}),typeof l.bin=="object")for(let[d,h]of Object.entries(l.bin))ge({key:`bin["${d}"]`,entryPath:h});return[...R.values()]};function xe(e){return e.replace(/(\.min)?\.(m|c)?jsx?$/,".d.$2ts")}var W=class extends F{},A={INVALID_MAIN_EXTENSION:()=>_`
    Only ${x(".js")}, ${x(".cjs")}, ${x(".mjs")}, ${x(".json")}, or ${x(".node")} allowed for ${b("main")} entry.

  `,INVALID_MODULE_EXTENSION:()=>_`
    Only ${x(".js")} or ${x(".mjs")} allowed for ${b("module")} entry.

  `,INVALID_TYPES_EXTENSION:()=>_`
    Only ${x(".d.ts")} or ${x(".d.cts")} or ${x(".d.mts")} allowed for ${b("types")} entry.

  `,INVALID_BIN_EXTENSION:()=>_`
    Only JavaScript files are allowed for ${x("bin")} entry.

  `,INVALID_PATH_KEY:e=>_`
    Invalid entry path ${x(e)}, entry path should starts with ${H("./")}.

  `,INVALID_DTS_FORMAT:()=>_`
    ${b("types")} entry must be .d.ts file and cannot be nested!

  `,INVALID_DTS_ORDER:()=>_`
    ${b("types")} entry must occur first in conditional exports for correct type resolution.

  `,UNDETEMINED_DTS_SOURCE:(e,t,o)=>_`
    ${b("types")} entry doesn't set properly for ${b(e)}:

        "require": "${t}",
        "import": "${o}"

    Solution 1. Explicitly set ${b("types")} entry
      
      For example like this

      + "types": "${t.replace(/\.(m|c)?js$/,".d.ts")}",
        "require": "${t}",
        "import": "${o}"

      Or like this

        "require": {
      +   "types": "${t.replace(/\.(m|c)?js$/,".d.$1ts")}",
          "default": "${t}"
        },
        "import": {
      +   "types": "${o.replace(/\.(m|c)?js$/,".d.$1ts")}",
          "default": "${o}"
        }

    Solution 2. Add ${b("default")} entry

        "require": "${t}",
        "import": "${o}",
      + "default": "/path/to/entry.js"

  `,SUBPATH_PATTERN:e=>_`
    Subpath pattern (${x(e)}) is not supported yet.

  `,CONFLICT_ENTRY:(e,t,o)=>Ue(_`
      Conflict found for ${x(e.entryPath)}

          %s
          %s

        vs

          %s ${ot.bold("(conflited)")}
          %s

    `,b(e.key),oe({module:e.module,platform:e.platform}),b(t.key),oe({module:t.module,platform:t.platform}))+o?`Hint: ${o}

`:"",PRECEDENSE_ENTRY:(e,t)=>Ue(_`
      Entry ${b(t.key)} will be ignored since

          %s
          %s

        precedense over

          %s ${ot.bold("(ignored)")}
          %s

    `,b(e.key),oe({module:e.module,platform:e.platform}),b(t.key),oe({module:t.module,platform:t.platform})),RECOMMEND_EXPORTS:()=>_`
    Using ${b("exports")} field is highly recommended.

      See ${ie("https://nodejs.org/api/packages.html")} for more detail.

  `,MODULE_NOT_RECOMMENDED:()=>_`
    ${b("module")} field is not standard and may works in only legacy bundlers. Consider using ${b("exports")} instead.
      See ${ie("https://nodejs.org/api/packages.html")} for more detail.

  `,TYPES_MAY_NOT_BE_RESOLVED:e=>_`
    ${b(e)} entry might not be resolved correctly in ${b("moduleResolution")}: ${H("Node16")}.

    Consider to specify ${b("types")} entry for it.

  `,NO_NEED_JSX:e=>_`
    ${x(e)} doesn't have to be \`.jsx\` unless you are using ${b("preserve")} mode.
  `,CUSTOM_CONDITION:e=>_`
    Custom condition ${b(e)} may has no effects.
  `};import tr from"string-dedent";import{performance as rr}from"node:perf_hooks";import{interpret as or}from"xstate";import{performance as Tt}from"node:perf_hooks";import Zt from"string-dedent";import{assign as Z,createMachine as er}from"xstate";function De(e){return e.module==="esmodule"||e.module==="commonjs"||e.module==="css"}function nt(e){return e.module==="dts"}function it(e){return e.module==="file"}function Lt(e){let t={mode:e.mode,module:e.module,minify:e.minify,platform:e.platform,sourcemap:e.sourcemap,customConditions:[...e.customConditions].sort()};return JSON.stringify(t)}function at(e){return JSON.parse(e)}function Vt(e){return{mode:e.mode,module:e.module,minify:e.minify,platform:e.platform,sourcemap:e.sourcemap,customConditions:e.customConditions}}function lt(e){let t={};for(let o of e){let s=Vt(o),r=Lt(s);t[r]?t[r].push(o):t[r]=[o]}return t}import*as ct from"esbuild";import Jt from"string-dedent";import*as ke from"node:fs";function Se(e){return ke.promises.access(e,ke.constants.F_OK).then(()=>!0).catch(()=>!1)}async function Oe(e){let t=null;for(let o of e)if(await Se(o)){t=o;break}return t}function ue(e){return/^(\.{0,2}\/).*/.test(e)}import*as de from"node:path";import*as pt from"node:fs/promises";var Re=/^(?<dirname>.+\/)(?<filename>(?<base>[^\/\.]+?)(?<ext>\..+)?)$/;async function ut(e){let{imports:t={}}=await pt.readFile(e.importMapsPath,"utf-8").then(JSON.parse);return{imports:t}}async function Ie({context:e,importMaps:t,rootKey:o}){for(let[s,r]of Object.entries(t.imports))if(typeof r=="object")await Ie({context:e,importMaps:{imports:r},rootKey:o||s});else{if(!(o||s).startsWith("#")&&(s.includes("*")||r.includes("*")))throw new ae("Subpath pattern (*) imports is supported only for Node.js-style imports like #pattern/*.js");if(!ue(r))continue;let k=de.resolve(de.dirname(e.importMapsPath),r.includes("*")?de.dirname(r):r);if(!await Se(k))throw new ae(`${x(k)} doesn't exist`)}return t}function dt(e,t){function o(l,m,u,i,c,g){if(typeof m=="string")return m;for(let[B,T]of Object.entries(m)){if(B==="node"&&c==="node")return typeof T=="string"?T:o(l,T,u,i,"node",g);if(B==="browser"&&c==="browser")return typeof T=="string"?T:o(l,m,u,i,"browser",g);if(B==="require"&&i==="commonjs")return typeof T=="string"?T:o(l,m,u,"commonjs",c,g);if(B==="import"&&i==="esmodule")return typeof T=="string"?T:o(l,m,u,"esmodule",c,g);if(B==="development"&&u==="development")return typeof T=="string"?T:o(l,m,"development",i,c,g);if(B==="production"&&u==="production")return typeof T=="string"?T:o(l,m,"production",i,c,g);if(g.includes(B)||B==="default")return typeof T=="string"?T:o(l,m,u,i,c,g)}return l}let{mode:s,module:r,platform:k,customConditions:a}=t,n={imports:{}};for(let[l,m]of Object.entries(e.imports))n.imports[l]=o(l,m,s,r,k,a);return n}function mt(e,t){var r,k,a,n,l,m,u,i,c,g,B,T,I,w;if(e.imports[t])return e.imports[t];let o=Object.entries(e.imports).sort(([j,Y])=>j.includes("*")?-1:0),s={};for(let[j,Y]of o){if(t.startsWith(j))return t.replace(j,Y);let R=s[j]||j.match(Re),y=s[Y]||Y.match(Re),M=s[t]||t.match(Re);if(((r=R==null?void 0:R.groups)==null?void 0:r.dirname)===((k=M==null?void 0:M.groups)==null?void 0:k.dirname)){if(((a=R==null?void 0:R.groups)==null?void 0:a.filename)==="*")return(((n=y==null?void 0:y.groups)==null?void 0:n.dirname)||"")+(((l=y==null?void 0:y.groups)==null?void 0:l.base)==="*"?((m=M==null?void 0:M.groups)==null?void 0:m.filename)+(((u=y==null?void 0:y.groups)==null?void 0:u.ext)||""):((i=y==null?void 0:y.groups)==null?void 0:i.filename)||"");if(((c=R==null?void 0:R.groups)==null?void 0:c.base)==="*"&&((g=R==null?void 0:R.groups)==null?void 0:g.ext)===((B=M==null?void 0:M.groups)==null?void 0:B.ext))return(((T=y==null?void 0:y.groups)==null?void 0:T.dirname)||"")+(((I=M==null?void 0:M.groups)==null?void 0:I.base)||"")+(((w=y==null?void 0:y.groups)==null?void 0:w.ext)||"")}}return t}import*as $e from"node:path";function ft({context:e,context:{reporter:t,standalone:o,externalDependencies:s,forceExternalDependencies:r},importMaps:k}){let a=(u,i)=>u===i||i.startsWith(u+"/"),n=u=>s.some(i=>u.startsWith(i))?!1:u.startsWith("node:")||Wt.some(i=>a(i,u)),l=u=>r.some(i=>a(i,u))?!1:o||!s.some(i=>a(i,u)),m=async u=>{let i=$e.resolve($e.dirname(e.importMapsPath),u);return await Oe([i.replace(/\.(c|m)?js$/,".tsx"),i.replace(/\.(c|m)?js$/,".ts"),i])||i};return{name:"nanobundle",setup(u){let i=!1;u.onResolve({filter:/.*/},async c=>{if(ue(c.path))return;let g=mt(k,c.path),B=!ue(g),T=n(g);return T&&(i=!0),!T&&l(g)?{}:{external:B,path:B?g:await m(g)}}),u.onEnd(()=>{o&&i&&t.warn("Not completely standalone bundle, while the code depends on some Node.js APIs.")})}}}var Wt=["assert","async_hooks","buffer","child_process","cluster","console","crypto","diagnostics_channel","dns","events","fs","http","http2","https","inspector","module","net","os","path","perf_hooks","process","readline","stream","string_decoder","timers","tls","trace_events","tty","dgram","url","util","v8","vm","wasi","worker_threads","zlib","querystring","_linklist","_stream_wrap","constants","domain","punycode","sys"];var je=class extends F{esbuildErrors;constructor(t,o){super(t),this.esbuildErrors=o}};async function yt({context:e,bundleEntries:t}){if(!e.bundle)return e.reporter.debug("buildBundleTask skipped since bundle=false"),{outputFiles:[]};if(t.length>0)e.reporter.debug(`start buildBundleTask for ${t.length} entries`);else return e.reporter.debug("there are no js entries, skipped buildBundleTask"),{outputFiles:[]};let o=await ut(e),s=await Ie({context:e,importMaps:o}),r=lt(t),k=[];for(let[u,i]of Object.entries(r)){let c=at(u);e.reporter.debug("bundle options %o",c),k.push(Gt({context:e,options:c,bundleEntries:i,validImportMaps:s,plugins:[]}))}let a=await Promise.all(k),n=a.flatMap(u=>u.errors);if(n.length>0)throw new je("Some errors occur while running esbuild",n);let l=a.flatMap(u=>u.warnings);if(l.length>0)for(let u of l)e.reporter.warn(u.text);return{outputFiles:a.flatMap(u=>u.outputFiles).map(u=>({path:u.path,content:u.contents}))}}async function Gt({context:e,plugins:t,validImportMaps:o,bundleEntries:s,options:r}){let k=[];for(let i of s){let c=await Oe(i.sourceFile);if(!c)throw new je(Jt`
        Source file does not exist.

          Expected one of
            - ${i.sourceFile.join(`
    - `)}

          But no matched files found.

        Please check your ${b("rootDir")} or ${b("outDir")} and try again.
        You can configure it in your ${x("tsconfig.json")}, or in CLI by ${G("--root-dir")} and ${G("--out-dir")} argument.

      `,[]);k.push({in:c,out:i.outputFile})}e.reporter.debug("esbuild entryPoints: %o",k);let a={bundle:!0,sourcemap:r.sourcemap,legalComments:e.legalComments?"linked":"none",minify:r.minify,define:{"process.env.NANOBUNDLE_PACKAGE_NAME":JSON.stringify(e.manifest.name||"unknown"),"process.env.NANOBUNDLE_PACKAGE_VERSION":JSON.stringify(e.manifest.version||"0.0.0")}};if(r.module==="commonjs"||r.module==="esmodule"){a={...a,tsconfig:e.tsconfigPath,jsx:e.jsx,jsxDev:e.jsxDev,jsxFactory:e.jsxFactory,jsxFragment:e.jsxFragment,jsxImportSource:e.jsxImportSource,treeShaking:!0,keepNames:!0,format:r.module==="commonjs"?"cjs":"esm",conditions:r.customConditions},r.platform==="deno"?(a.platform="neutral",a.target=e.targets.filter(g=>g.startsWith("deno"))):(a.platform=r.platform,r.platform==="node"?a.target=e.targets.filter(g=>g.startsWith("node")):a.target=e.targets.filter(g=>!(g.startsWith("node")||g.startsWith("deno")))),r.mode&&(a.define={...a.define,"process.env.NODE_ENV":JSON.stringify(r.mode),"process.env.NANOBUNDLE_MODE":JSON.stringify(r.mode)});let i=dt(o,r),c=ft({context:e,importMaps:i});a.plugins=[c,...t]}e.reporter.debug("esbuild build options %o",a);let n=await Promise.all(k.map(i=>ct.build({...a,entryPoints:[i.in],outfile:i.out,write:!1}))),l=n.flatMap(i=>i.outputFiles.filter(c=>!(c.path.endsWith(".LEGAL.txt")&&c.contents.length===0)).map(c=>({...c,path:c.path}))),m=n.flatMap(i=>i.errors),u=n.flatMap(i=>i.warnings);return{errors:m,warnings:u,outputFiles:l}}import*as gt from"node:fs/promises";import Yt from"string-dedent";var Me=class extends F{reasons;constructor(t){super(),this.reasons=t}};async function bt({context:e,fileEntries:t}){if(!e.bundle)return e.reporter.debug("buildFileTask skipped since bundle=false"),{outputFiles:[]};if(t.length>0)e.reporter.debug(`start buildFileTask for ${t.length} entries`);else return e.reporter.debug("there are no file entries, skipped buildFileTask"),{outputFiles:[]};let o=[];for(let n of t){let l=n.sourceFile[0],m=n.outputFile;if(l===m){e.reporter.debug(Yt`
        noop for ${b(n.key)} because of source path and output path are the same.
          entry path: ${x(n.entryPath)}
      `);continue}o.push(Xt({sourceFile:l,outputFile:m}))}let s=await Promise.allSettled(o),r=s.filter(n=>n.status==="rejected");if(r.length)throw new Me(r.map(n=>n.reason));return{outputFiles:s.map(n=>n.value.outputFile)}}async function Xt({sourceFile:e,outputFile:t}){let o=await gt.readFile(e);return{outputFile:{sourcePath:e,path:t,content:o}}}import Te from"string-dedent";import{parseNative as zt}from"tsconfck";var Pe=class extends F{},_e=class extends F{constructor(t,o,s){let r=Te`
      [error] TypeScript compilation failed

      ${re(te?t.formatDiagnosticsWithColorAndContext(s,o):t.formatDiagnostics(s,o),1)}
    `;super(r)}};async function ht({context:e,typeEntries:t}){if(!e.declaration)return e.reporter.debug("buildTypeTask skipped since declaration=false"),{outputFiles:[]};if(!e.tsconfigPath)return e.reporter.debug("buildTypeTask skipped since no tsconfig.json provided"),{outputFiles:[]};if(t.length>0)e.reporter.debug(`start buildTypeTask for ${t.length} entries`);else return e.reporter.debug("there are no dts entries, skipped buildTypeTask"),{outputFiles:[]};let o;try{o=await import("typescript").then(m=>m.default)}catch{throw new Pe(Te`
      Couldn't load TypeScript API

        Try ${G("npm i -D typescript")} or ${G("yarn add -D typescript")} and build again.

    `)}e.reporter.debug("loaded TypeScript compiler API version %s",o.version);let{result:s}=await zt(e.tsconfigPath),r={...s.options,rootDir:e.rootDir,outDir:e.outDir,allowJs:!0,composite:!1,incremental:!1,skipLibCheck:!0,declaration:!0,emitDeclarationOnly:!0};r.noEmit&&e.reporter.warn(Te`
      Ignored ${b("noEmit")} specified in your tsconfig.json

        You can disable emitting declaration via ${G("--no-dts")} flag.

    `),r.noEmit=!1,r.moduleResolution===o.ModuleResolutionKind.Node16||r.moduleResolution===o.ModuleResolutionKind.NodeNext||e.reporter.warn(Te`
      nanobundle recommends to use ${H("Node16")} or ${H("NodeNext")} for ${b("compilerOptions.moduleResolution")}

        See ${ie("https://www.typescriptlang.org/docs/handbook/esm-node.html")} for more detail.

    `),e.reporter.debug("loaded compilerOptions %o",r);let k=new Map,a=o.createCompilerHost(r);a.writeFile=(m,u)=>{e.reporter.debug(`ts program emitted file to ${x(m)}`),k.set(m,Buffer.from(u,"utf-8"))};let n=[];for(let m of t){let u=o.createProgram(m.sourceFile,r,a);e.reporter.debug("created ts program from %o",m.sourceFile);let i=u.emit(),c=qt(o.getPreEmitDiagnostics(u).concat(i.diagnostics)),g=[];for(let B of c)if(!Ht.includes(B.code))switch(B.category){case o.DiagnosticCategory.Error:{g.push(B);break}default:{n.push(B);break}}if(g.length>0)throw new _e(o,a,g)}return n.length>0&&e.reporter.warn(te?o.formatDiagnosticsWithColorAndContext(n,a):o.formatDiagnostics(n,a)),{outputFiles:[...k.entries()].map(([m,u])=>({path:m,content:u}))}}function qt(e){let t=[],o=new Set,s=new Set;for(let r of e)r.file?s.has(r.file.fileName)||(s.add(r.file.fileName),t.push(r)):o.has(r.code)||(o.add(r.code),t.push(r));return t}var Ht=[6053];import*as Et from"node:fs/promises";async function xt({context:e,binEntries:t}){let o=[];for(let s of t)o.push(Et.chmod(s.outputFile,"+x"));return await Promise.all(o),{}}import*as Ae from"node:fs/promises";var Le=class extends F{reasons;constructor(t){super(),this.reasons=t}};async function we({context:e,outputFiles:t}){let o=e.resolvePath(e.outDir),s=e.resolveRelativePath(o);if(s!==""&&!s.startsWith(".."))return e.reporter.info(`\u{1F5D1}\uFE0F  ${x("./"+s)}`),await Ae.rm(o,{recursive:!0,force:!0}),{};let r=[];for(let n of t){if(n.path===n.sourcePath){e.reporter.debug(`src=dest for ${n.path}, skipping`);continue}e.reporter.info(`\u{1F5D1}\uFE0F  ${x("./"+e.resolveRelativePath(n.path))}`),r.push(Ae.rm(n.path,{force:!0}))}let a=(await Promise.allSettled(r)).filter(n=>n.status==="rejected");if(a.length)throw new Le(a.map(n=>n.reason));return{}}import*as ve from"node:fs/promises";import*as kt from"node:path";var Ve=class extends F{reasons;constructor(t){super(),this.reasons=t}};async function Ot({outputFiles:e}){let t=[];for(let r of e)t.push(ve.mkdir(kt.dirname(r.path),{recursive:!0}).then(()=>ve.writeFile(r.path,r.content)));let s=(await Promise.allSettled(t)).filter(r=>r.status==="rejected");if(s.length)throw new Ve(s.map(r=>r.reason));return{outputFiles:e}}import*as Ce from"node:zlib";import{promisify as $t}from"node:util";import me from"string-dedent";import We from"pretty-bytes";var Kt=$t(Ce.gzip),Qt=$t(Ce.brotliCompress);async function jt({context:e,bundleOutputs:t,fileOutputs:o,typeOutputs:s}){let r=t.filter(n=>!n.path.endsWith(".map")).filter(n=>!n.path.endsWith(".LEGAL.txt")),k=r.at(-1),a=r.length!==1;e.reporter.info(me`
    ${a?"Bundles":"A bundle"} generated

  `);for(let n of r){let[l,m]=await Promise.all([Kt(n.content),Qt(n.content)]);e.reporter.info(me`
      📦 ${x(e.resolveRelativePath(n.path,!0))}${e.verbose?`
`+re(me`
        Size      : ${We(n.content.byteLength)}
        Size (gz) : ${We(l.byteLength)}
        Size (br) : ${We(m.byteLength)}

      `,1):n===k?`
`:""}
    `)}if(s.length>0&&e.reporter.info(me`
      Also ${s.length} declaration ${a?"files are":"file is"} generated

      ${e.verbose?`  \u{1F4E6} ${s.map(n=>x(e.resolveRelativePath(n.path,!0))).join(`
  \u{1F4E6} `)}
`:""}
    `),o.length>0){for(let n of o)e.reporter.info(me`
        Copied ${x(e.resolveRelativePath(n.sourcePath,!0))} to ${x(e.resolveRelativePath(n.path,!0))}
      `);console.log()}}var wt=er({tsTypes:{},schema:{events:{},context:{}},predictableActionArguments:!0,id:"buildMachine",initial:"bootstrap",states:{bootstrap:{on:{BUILD:{target:"buildEntries",actions:"reportBuildStart"},CLEAN:"cleanupFirst"}},buildEntries:{states:{buildBundleEntries:{initial:"build",states:{build:{invoke:{src:"buildBundleTask",onDone:[{target:"success",actions:"assignBundleOutputs"}],onError:[{target:"failure",actions:"assignBuildBundleError"}]}},success:{type:"final"},failure:{type:"final"}}},buildFileEntries:{initial:"build",states:{build:{invoke:{src:"buildFileTask",onDone:[{target:"success",actions:"assignFileOutputs"}],onError:[{target:"failure",actions:"assignBuildFileError"}]}},success:{type:"final"},failure:{type:"final"}}},buildTypeEntries:{initial:"build",states:{build:{invoke:{src:"buildTypeTask",onDone:[{target:"success",actions:"assignTypeOutputs"}],onError:[{target:"failure",actions:"assignBuildTypeError"}]}},success:{type:"final"},failure:{type:"final"}}}},type:"parallel",onDone:[{target:"cleanup",cond:"hasBuildErrors",actions:"reportBuildErrors"},{target:"emitEntries"}]},emitEntries:{invoke:{src:"emitTask",onDone:[{target:"reportEmitResults"}],onError:[{target:"cleanup",actions:"assignEmitError"}]}},done:{entry:"reportBuildEnd",type:"final"},cleanup:{invoke:{src:"cleanupTask",onDone:[{target:"done"}],onError:[{target:"done"}]}},chmodBinEntries:{invoke:{src:"chmodBinTask",onDone:[{target:"done"}],onError:[{target:"done"}]}},reportEmitResults:{invoke:{src:"reportEmitResults",onDone:[{target:"chmodBinEntries",cond:"hasBinEntries"},{target:"done"}]}},cleanupFirst:{invoke:{src:"cleanupTask",onDone:"bootstrap",onError:"bootstrap"},entry:"reportCleanupStart",exit:"reportCleanupEnd"}}},{guards:{hasBuildErrors:e=>Object.values(e.errors).some(Boolean),hasBinEntries:e=>e.entries.some(t=>t.key.startsWith("bin"))},actions:{reportBuildStart:Z({buildStartedAt:e=>Tt.now()}),reportBuildEnd:e=>{if(Object.values(e.errors).some(Boolean))return;let s=(Tt.now()-e.buildStartedAt).toFixed(1);e.root.reporter.info(`\u26A1 Done in ${s}ms.`)},reportCleanupStart:e=>{e.root.reporter.info(Zt`
          Cleanup outputs first

        `)},reportCleanupEnd:e=>{console.log()},reportBuildErrors:e=>{if(e.errors.buildBundle){e.root.reporter.error(e.errors.buildBundle.message);for(let t of e.errors.buildBundle.esbuildErrors)e.root.reporter.error(t.text)}if(e.errors.buildFile)for(let t of e.errors.buildFile.reasons)e.root.reporter.captureException(t);e.errors.buildType&&e.root.reporter.captureException(e.errors.buildType)},assignBundleOutputs:Z({bundleOutputs:(e,t)=>[...e.bundleOutputs,...t.data.outputFiles]}),assignFileOutputs:Z({bundleOutputs:(e,t)=>[...e.fileOutputs,...t.data.outputFiles]}),assignTypeOutputs:Z({typeOutputs:(e,t)=>[...e.typeOutputs,...t.data.outputFiles]}),assignBuildBundleError:Z({errors:(e,t)=>({...e.errors,buildBundle:t.data})}),assignBuildFileError:Z({errors:(e,t)=>({...e.errors,buildFile:t.data})}),assignBuildTypeError:Z((e,t)=>({errors:{...e.errors,buildType:t.data}})),assignEmitError:Z({errors:(e,t)=>({...e.errors,emit:t.data})})},services:{buildBundleTask:e=>yt({context:e.root,bundleEntries:e.entries.filter(De)}),buildFileTask:e=>bt({context:e.root,fileEntries:e.entries.filter(it)}),buildTypeTask:e=>ht({context:e.root,typeEntries:e.entries.filter(nt)}),emitTask:e=>Ot({context:e.root,outputFiles:[...e.bundleOutputs,...e.fileOutputs,...e.typeOutputs]}),reportEmitResults:e=>jt({context:e.root,bundleOutputs:e.bundleOutputs,fileOutputs:e.fileOutputs,typeOutputs:e.typeOutputs}),cleanupTask:e=>we({context:e.root,outputFiles:e.entries.map(t=>({sourcePath:t.sourceFile[0],path:t.outputFile}))}),chmodBinTask:e=>xt({context:e.root,binEntries:e.entries.filter(De).filter(t=>t.key.startsWith("bin"))})}});async function vt({context:e,entries:t,cleanFirst:o=!1}){e.reporter.info(tr`
    Build ${he(e.manifest.name||"unnamed")} package

  `);let s=or(wt.withContext({root:e,entries:t,bundleOutputs:[],fileOutputs:[],typeOutputs:[],errors:{},buildStartedAt:rr.now()}));return s.start(),o?(s.send("CLEAN"),s.onTransition(r=>{r.can("BUILD")&&s.send("BUILD")})):s.send("BUILD"),new Promise((r,k)=>{s.onDone(()=>{let a=s.getSnapshot();Object.values(a.context.errors).some(Boolean)?k(new F):r()})})}import sr from"string-dedent";async function Ct({context:e,entries:t}){e.reporter.info(sr`
    Clean ${he(e.manifest.name||"unnamed")} package

  `);let o=t.map(s=>({sourcePath:s.sourceFile[0],path:s.outputFile}));await we({context:e,outputFiles:o})}var{flags:fe,input:ir}=Be,[ce]=ir,J=new Ee(console);J.level=process.env.DEBUG==="true"?"debug":"default";ce||Be.showHelp(0);var ar=["build","clean"];try{if(ar.includes(ce)){let e=await tt({basePath:fe.cwd});J.debug("loaded manifest %o",e);let t;try{t=await nr(fe.tsconfig)}catch(n){if(n instanceof Ft)throw n}let o=t==null?void 0:t.tsconfigFile;o&&J.debug(`loaded tsconfig from ${o}`);let s=t==null?void 0:t.tsconfig;s&&J.debug("loaded tsconfig %o",s);let r=Qe({manifest:e,basePath:fe.cwd});J.debug(`loaded targets ${r.join(", ")}`);let k=rt({flags:fe,targets:r,manifest:e,tsconfig:s,tsconfigPath:o,reporter:J});J.debug("loaded context %o",k);let a=st({context:k,reporter:J});if(a.some(n=>n.module==="dts")&&o==null)throw new pe(Bt`
        You have set ${b("types")} entry. But no ${x("tsconfig.json")} found.

          Please create ${x("tsconfig.json")} file in the current directory, or pass its path to ${G("--tsconfig")} argument.

      `);J.debug("parsed entries %o",a),ce==="build"&&await vt({context:k,entries:a,cleanFirst:fe.clean}),ce==="clean"&&await Ct({context:k,entries:a})}else throw new F(Bt`
      Command "${ce}" is not available.

        Run ${G("nanobundle --help")} for usage.
    `)}catch(e){e instanceof F||e instanceof Ft?J.error(e.message):J.captureException(e),process.exit(1)}
