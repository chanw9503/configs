{
  "version": 3,
  "sources": ["../src/index.ts", "../src/common.ts", "../src/promise.ts", "../src/function.ts", "../src/option.ts", "../src/condition.ts", "../src/tuple.ts", "../src/result.ts", "../src/json.ts"],
  "sourcesContent": ["export * from './common';\nexport * from './promise';\nexport * as Fn from './function';\nexport * as Option from './option';\nexport * as Condition from './condition';\nexport * as Tuple from './tuple';\nexport * as Result from './result';\nexport * as JSON from './json';\n", "/**\n * Any object that can be called\n */\nexport interface Callable {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (...args: any[]): any;\n}\n\nexport function callable(v: unknown): Callable {\n  if (typeof v !== 'function') {\n    throw new Error(`Expected a callable value, but got ${typeof v}`);\n  }\n  return v as Callable;\n}\n\n/**\n * Assert given value is non-nullable, and tell it to TypeScript\n */\nexport function required<T>(v: T): asserts v {\n  if (v == null) {\n    throw new Error(`Expected non nullable, but got ${typeof v}`);\n  }\n}\n\n/**\n * JavaScript's primitive types\n */\nexport type Primitive = (\n  | null\n  | undefined\n  | boolean\n  | string\n  | number\n  | bigint\n  | symbol\n);\n\n/**\n * Alternative to `any`\n *\n * Helpful when need `any` as value type but should be inferred more precisely\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type InferrableAny = Primitive | object;\n\n/**\n * Simulate Flow's `$NonMaybeType<mixed>`.\n * Theoretically same as `Exclude<unknown, null | undefined>` that doesn't work on current version of TypeScript.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type NonMaybeType = {};\n\n/**\n * Strict presentation of empty object\n */\nexport type EmptyObject = Record<string, never>;\n\n/**\n * Strict presentation of any object\n */\nexport type AnyObject = Record<string, unknown>;\n\n/**\n * Safely intersect prop types\n */\nexport type OverrideProps<TBaseProps, TNewProps> = Omit<TBaseProps, keyof TNewProps> & TNewProps;\n\n/**\n * Well-known `U<T>`-like nominal types\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type BoxType<T = any> = (\n  | Promise<T>\n  // eslint-disable-next-line @typescript-eslint/array-type\n  | Array<T>\n  | Set<T>\n);\n\n/**\n * Unwrap BoxType<T>.\n */\nexport type Unwrap<T> = (\n  T extends Promise<infer U> ? U :\n  T extends Array<infer U> ? U :\n  T extends Set<infer U> ? U :\n  never\n);\n\n/**\n * Wrap T by BoxType.\n */\nexport type Wrap<T, Box extends BoxType> = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Box extends Promise<any> ? Promise<T> :\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/array-type\n  Box extends Array<any> ? Array<T> :\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Box extends Set<any> ? Set<T> :\n  never\n);\n\nexport type OneOrMany<T> = T | T[];\n\n/**\n * Check type-level equally of given two types.\n *\n * the first one (or `A` if specified) is going to return type if true,\n * or returns `never` (of `B` if specified)\n */\nexport type IfEquals<X, Y, A = X, B = never> = (\n  (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2)\n  ? A\n  : B\n);\n\n/**\n * @see https://stackoverflow.com/a/49725198/5734400\n */\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = (\n  & Pick<T, Exclude<keyof T, Keys>>\n  & {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n  }[Keys]\n);\n\n/**\n * @see https://stackoverflow.com/a/49725198/5734400\n */\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = (\n  & Pick<T, Exclude<keyof T, Keys>>\n  & {\n    [K in Keys]-?: (\n      & Required<Pick<T, K>>\n      & Partial<Record<Exclude<Keys, K>, undefined>>\n    )\n  }[Keys]\n);\n\n/**\n * A callable object do nothing\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop: Callable = () => {};\n\n/**\n * identity\n */\nexport const ident = <X>(x: X): X => x;\n\n/**\n * for type-level assertion\n */\n/* istanbul ignore next */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function expectType<T>(_: T): void {}\n\n/**\n * for type-level assertion (loose)\n */\n/* istanbul ignore next */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function expectAssignable<A, B extends A = A>(_: B): void {}\n\n/**\n * Check if given two type params are equal.\n */\n/* istanbul ignore next */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function expectEquals<A, B>(..._: IfEquals<A, B, [true?], [false]>): void {}\n", "import { noop } from './common';\n\nexport function timeout(ms: number) {\n  return new Promise<void>(resolve => void setTimeout(resolve, ms));\n}\n\nexport interface Deferred<T> extends Promise<T> {\n  resolve(value: T): void;\n  reject(reason?: unknown): void;\n}\n\nexport function defer<T>(): Deferred<T> {\n  let resolve: (value: T) => void = noop;\n  let reject: (reason?: unknown) => void = noop;\n  const deferred = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return Object.assign(deferred, { resolve, reject });\n}\n", "import type { Callable } from './common';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type T<Y, X = any> = (\n  | Y\n  | ((domain: X) => Y)\n);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Domain<TFn> = TFn extends ((x: infer X) => any) ? X : void;\n\nexport type Range<TFn> = TFn extends T<infer R> ? R : never;\n\n/**\n * Returns result of function, or value as-is.\n *\n * @param fn A function value\n * @param arg A argument to pass to function.\n *            It will be dropped if the given `fn` is not a callable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function range<R, X = any>(fn: T<R, X>, ...arg: [X?] | []): R {\n  if (typeof fn === 'function') {\n    return (fn as Callable)(...arg) as R;\n  }\n  return fn;\n}\n\nexport type MergeRange<\n  TFunction\n> =\n  TFunction extends Record<string, T<unknown>> ? Range<TFunction[keyof TFunction]>\n  : TFunction extends Array<T<unknown>> ? Range<TFunction[number]>\n  : never;\n", "// Type-first utilities to handle optional values (not lazy)\n\nimport * as Fn from './function';\n\nexport type None = null | undefined;\nexport type Some<X> = Exclude<X, None>;\nexport type T<X> = Some<X> | None;\n\nexport function of<X>(x: Fn.T<X>): T<X> {\n  return Fn.range(x) as T<X>;\n}\n\n/**\n * Make Option<T> by throwable factory fn\n */\nexport function ofUnsafe<X>(throwable: () => T<X>): T<X> {\n  try {\n    return throwable();\n  } catch {\n    return null;\n  }\n}\n\nexport function isSome<X>(option: T<X>): option is Some<X> {\n  return option != null;\n}\n\nexport function isNone<X>(option: T<X>): option is None {\n  return option == null;\n}\n\n/**\n * Populate typename of `Option<T>`\n *\n * @param option\n *\n * @return Given `Option<string>`, returns `\"Some(string)\"` or `\"None\"`\n */\nexport function toString<X>(option: T<X>): string {\n  return isSome(option) ? `Some(${typeof option})` : 'None';\n}\n\n/**\n * Match the given option\n *\n * @param option\n *\n * @return `'some' | 'none'`\n */\nexport function match<X>(option: T<X>): 'Some' | 'None' {\n  return isSome(option) ? 'Some' : 'None';\n}\n\n/**\n * Subtype mapper for optional value.\n *\n * @param option\n * @param map A Function to map some, or an object to map both some and none.\n *\n * @example\n * ```ts\n * let args: Option<Array<string>>;\n *\n * // Expect: Option<string>\n * const optionalArgString = mapOption(args, args => args.join(' '));\n *\n * // Expect: string\n * const argString = mapOption(args, {\n *   Some: args => args.join(' '),\n *   None: '', // default value\n * });\n * ```\n */\nexport function map<X, RSome, RNone = None>(\n  option: T<X>,\n  fn: (\n    | ((t: Some<X>) => RSome)\n    | ({\n      Some: Fn.T<RSome, Some<X>>,\n      None: Fn.T<RNone, void>,\n    })\n  ),\n): RSome | RNone {\n  if (typeof fn === 'function') {\n    return isSome(option)\n      ? fn(option)\n      // Only None value can be here.\n      : null as unknown as RNone;\n  }\n\n  if (typeof fn !== 'object') {\n    throw new Error(\n      `The second argument only allows function or object but got: ${typeof fn}`,\n    );\n  }\n\n  const pattern = match(option);\n  if (!(pattern in fn)) {\n    throw new Error(\n      `The object doesn't have bind to ${toString(option)} pattern`,\n    );\n  }\n  return Fn.range<RSome | RNone>(fn[pattern], option);\n}\n\nexport function getExn<X>(option: T<X>, errorFactory?: () => Error): Some<X> {\n  return map(option, {\n    Some: v => v,\n    None: () => {\n      const error = errorFactory?.() ?? new Error('You tried to get T of Option<T>, ut T is None');\n      throw error;\n    },\n  });\n}\n", "import type { InferrableAny } from './common';\nimport * as Fn from './function';\n\nexport type Falsy = (\n  | false\n  | null\n  | undefined\n  | 0\n  | -0\n  | 0n\n  | ''\n);\n\nexport type Truthy<X = InferrableAny> = Exclude<X, Falsy>;\n\nexport type T<X> = (\n  | Truthy<X>\n  | Falsy\n);\n\nexport function isTruthy<X>(condition: T<X>): condition is Truthy<X> {\n  return !!condition;\n}\n\nexport function isFalsy<X>(condition: T<X>): condition is Falsy {\n  return !condition;\n}\n\nexport function of<X>(condition: X): T<X> {\n  return condition as T<X>;\n}\n\nexport function map<X, R>(condition: T<X>, fn: Fn.T<Truthy<R>, X>): T<R> {\n  if (isTruthy(condition)) {\n    return Fn.range(fn, condition);\n  }\n  return condition;\n}\n", "import type {\n  Wrap,\n  Unwrap,\n  BoxType,\n} from './common';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-namespace */\n\n// Core utility borrowed from $mol_type\n// See https://github.com/eigenmethod/mol/tree/master/type\nexport type Head<Tuple extends readonly any[]> = (\n  Tuple['length'] extends 0\n    ? never\n    : Tuple[0]\n);\n\n// Core utility borrowed from $mol_type\n// See https://github.com/eigenmethod/mol/tree/master/type\nexport type Tail<Tuple extends readonly any[]> = (\n  (\n    (...tail: Tuple) => any\n  ) extends (\n    (head: any, ...tail: infer Tail) => any\n  )\n    ? Tail\n    : never\n);\n\nexport type Append<\n  Tuple extends readonly any[],\n  Item\n> = [...Tuple, Item];\n\nexport type Prepend<\n  Tuple extends readonly any[],\n  Item\n> = [Item, ...Tuple];\n\n// Simulate Flow's `$TupleMap<T, F>` utility.\n// Copy-pasted bunch of utils using the same pattern because the TypeScript doesn't have `$Call` type.\n\nexport type MapPromise<\n  Tuple extends readonly any[],\n  Result extends readonly any[] = []\n> = {\n  0: Result,\n  1: MapPromise<\n    Tail<Tuple>,\n    Append<Result, Promise<Head<Tuple>>>\n  >,\n}[Tuple['length'] extends 0 ? 0 : 1];\n\nexport type MapReturnType<\n  Tuple extends readonly any[],\n  Result extends readonly any[] = []\n> = {\n  0: Result,\n  1: MapReturnType<\n    Tail<Tuple>,\n    Append<Result, ReturnType<Head<Tuple>>>\n  >,\n}[Tuple['length'] extends 0 ? 0 : 1];\n\nexport type MapPick<\n  Tuple extends readonly any[],\n  Key extends string,\n  Result extends readonly any[] = []\n> = {\n  0: Result,\n  1: MapPick<\n    Tail<Tuple>,\n    Key,\n    Append<Result, Pick<Head<Tuple>, Key>>\n  >,\n}[Tuple['length'] extends 0 ? 0 : 1];\n\nexport type MapUnwrap<\n  Tuple extends readonly any[],\n  Result extends readonly any[] = []\n> = {\n  0: Result,\n  1: MapUnwrap<\n    Tail<Tuple>,\n    Append<Result, Unwrap<Head<Tuple>>>\n  >,\n}[Tuple['length'] extends 0 ? 0 : 1];\n\nexport type MapWrap<\n  Tuple extends readonly any[],\n  Box extends BoxType<any>,\n  Result extends readonly any[] = []\n> = {\n  0: Result,\n  1: MapWrap<\n    Tail<Tuple>,\n    Box,\n    Append<Result, Wrap<Head<Tuple>, Box>>\n  >,\n}[Tuple['length'] extends 0 ? 0 : 1];\n\n/**\n * Make tuple of T and given length\n *\n * Borrowed from https://github.com/microsoft/TypeScript/pull/40002#issue-466243948\n */\nexport type T<X, N extends number> = N extends N ? number extends N ? X[] : _T<X, N> : never;\ntype _T<X, N extends number> = MakeTuple<X, N>;\n\n/**\n * Credits to [Gal Schlezinger](https://github.com/schniz)\n * @see https://twitter.com/galstar/status/1299265344226439169\n */\ntype MakeTuple<X, N extends number, Result extends readonly X[] = []> = {\n  0: Result,\n  1: MakeTuple<X, N, [X, ...Result]>,\n}[Result['length'] extends N ? 0 : 1];\n\nexport type Replace<Tuple extends readonly any[], X, Result extends readonly X[] = []> = {\n  0: Result,\n  1: Replace<Tail<Tuple>, X, [X, ...Result]>,\n}[Tuple['length'] extends 0 ? 0 : 1];\n", "import type { Callable, Unwrap } from './common';\nimport * as Fn from './function';\n\nconst s_ok = Symbol('ok');\nconst s_err = Symbol('err');\n\nexport type Ok<T> = [typeof s_ok, T];\nexport type Err<T = unknown> = [typeof s_err, T];\nexport type T<TOk, TError = unknown> = Ok<TOk> | Err<TError>;\n\nexport function ok<TOk = void>(t: TOk | void): Ok<TOk> {\n  return [s_ok, t as TOk];\n}\n\nexport function err<TError = void>(t: TError | void): Err<TError> {\n  return [s_err, t as TError];\n}\n\nexport function ofUnsafe<TUnsafe extends Callable>(unsafe: TUnsafe): T<ReturnType<TUnsafe>> {\n  try {\n    return ok(unsafe());\n  } catch (e) {\n    return err(e);\n  }\n}\n\nexport async function ofPromise<\n  TPromise extends Promise<unknown>,\n  TOk extends Unwrap<TPromise> = Unwrap<TPromise>,\n>(\n  promiseFn: Fn.T<TPromise, void>,\n): Promise<T<TOk>> {\n  try {\n    const result = (await Fn.range(promiseFn)) as TOk;\n    return ok(result);\n  } catch (e) {\n    return err(e);\n  }\n}\n\nexport function match<TOk, TError>(result: T<TOk, TError>): 'Ok' | 'Err' {\n  return isOk(result) ? 'Ok' : 'Err';\n}\n\nexport function toString<TOk, TError>(result: T<TOk, TError>): string {\n  return `${match(result)}(${typeof result})`;\n}\n\nexport function isOk<TOk>(t: T<TOk, unknown>): t is Ok<TOk> {\n  return t[0] === s_ok;\n}\n\nexport function isErr<TError>(t: T<unknown, TError>): t is Err<TError> {\n  return t[0] === s_err;\n}\n\nexport function getExn<TOk>(result: T<TOk, unknown>): TOk {\n  if (isOk(result)) {\n    return result[1];\n  }\n  throw new Error(`Expected Ok<T>, but got: ${toString(result)}`);\n}\n\nexport function getWithDefault<TOk>(\n  result: T<TOk, unknown>,\n  defaultValue: TOk,\n): TOk {\n  return isOk(result)\n    ? result[1]\n    : defaultValue;\n}\n\nexport function getErrExn<TError>(result: T<unknown, TError>): TError {\n  if (isErr(result)) {\n    return result[1];\n  }\n  throw new Error(`Expected Err<T>, but got: ${toString(result)}`);\n}\n\nexport function getErrWithDefault<TError>(\n  result: T<unknown, TError>,\n  defaultValue: TError,\n): TError {\n  return isErr(result)\n    ? result[1]\n    : defaultValue;\n}\n\nexport function map<\n  TOk,\n  TError,\n  ROk,\n  RError = TError,\n>(\n  result: T<TOk, TError>,\n  fn: (\n    | ((t: TOk) => ROk)\n    | ({\n      Ok: Fn.T<ROk, TOk>,\n      Err: Fn.T<RError, TError>,\n    })\n  ),\n): T<ROk, RError> {\n  if (typeof fn === 'function') {\n    return isOk(result)\n      ? ok(fn(result[1]))\n      : result as unknown as Err<RError>;\n  }\n\n  if (typeof fn !== 'object') {\n    throw new Error(\n      `The second argument only allows function or object but got: ${typeof fn}`,\n    );\n  }\n\n  const pattern = match(result);\n  if (!(pattern in fn)) {\n    throw new Error(\n      `The object doesn't have bind to ${pattern} pattern`,\n    );\n  }\n\n  return isOk(result)\n    ? ok(Fn.range(fn.Ok, result[1]))\n    : err(Fn.range(fn.Err, result[1]));\n}\n", "export type SerializableValue = (\n  | null\n  | number\n  | string\n  | boolean\n  | SerializableValue[]\n  | SerializableObject\n);\n\nexport type SerializableObject = {\n  [x: string]: SerializableValue,\n};\n"],
  "mappings": "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",
  "names": ["map", "of", "of", "map", "getExn", "map", "match", "ofUnsafe", "toString", "ofUnsafe", "match", "toString", "getExn", "map"]
}
