import type { Callable, Unwrap } from './common';
import * as Fn from './function';
declare const s_ok: unique symbol;
declare const s_err: unique symbol;
export type Ok<T> = [typeof s_ok, T];
export type Err<T = unknown> = [typeof s_err, T];
export type T<TOk, TError = unknown> = Ok<TOk> | Err<TError>;
export declare function ok<TOk = void>(t: TOk | void): Ok<TOk>;
export declare function err<TError = void>(t: TError | void): Err<TError>;
export declare function ofUnsafe<TUnsafe extends Callable>(unsafe: TUnsafe): T<ReturnType<TUnsafe>>;
export declare function ofPromise<TPromise extends Promise<unknown>, TOk extends Unwrap<TPromise> = Unwrap<TPromise>>(promiseFn: Fn.T<TPromise, void>): Promise<T<TOk>>;
export declare function match<TOk, TError>(result: T<TOk, TError>): 'Ok' | 'Err';
export declare function toString<TOk, TError>(result: T<TOk, TError>): string;
export declare function isOk<TOk>(t: T<TOk, unknown>): t is Ok<TOk>;
export declare function isErr<TError>(t: T<unknown, TError>): t is Err<TError>;
export declare function getExn<TOk>(result: T<TOk, unknown>): TOk;
export declare function getWithDefault<TOk>(result: T<TOk, unknown>, defaultValue: TOk): TOk;
export declare function getErrExn<TError>(result: T<unknown, TError>): TError;
export declare function getErrWithDefault<TError>(result: T<unknown, TError>, defaultValue: TError): TError;
export declare function map<TOk, TError, ROk, RError = TError>(result: T<TOk, TError>, fn: (((t: TOk) => ROk) | ({
    Ok: Fn.T<ROk, TOk>;
    Err: Fn.T<RError, TError>;
}))): T<ROk, RError>;
export {};
