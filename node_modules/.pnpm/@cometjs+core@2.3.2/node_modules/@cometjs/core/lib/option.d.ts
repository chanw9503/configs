import * as Fn from './function';
export type None = null | undefined;
export type Some<X> = Exclude<X, None>;
export type T<X> = Some<X> | None;
export declare function of<X>(x: Fn.T<X>): T<X>;
/**
 * Make Option<T> by throwable factory fn
 */
export declare function ofUnsafe<X>(throwable: () => T<X>): T<X>;
export declare function isSome<X>(option: T<X>): option is Some<X>;
export declare function isNone<X>(option: T<X>): option is None;
/**
 * Populate typename of `Option<T>`
 *
 * @param option
 *
 * @return Given `Option<string>`, returns `"Some(string)"` or `"None"`
 */
export declare function toString<X>(option: T<X>): string;
/**
 * Match the given option
 *
 * @param option
 *
 * @return `'some' | 'none'`
 */
export declare function match<X>(option: T<X>): 'Some' | 'None';
/**
 * Subtype mapper for optional value.
 *
 * @param option
 * @param map A Function to map some, or an object to map both some and none.
 *
 * @example
 * ```ts
 * let args: Option<Array<string>>;
 *
 * // Expect: Option<string>
 * const optionalArgString = mapOption(args, args => args.join(' '));
 *
 * // Expect: string
 * const argString = mapOption(args, {
 *   Some: args => args.join(' '),
 *   None: '', // default value
 * });
 * ```
 */
export declare function map<X, RSome, RNone = None>(option: T<X>, fn: (((t: Some<X>) => RSome) | ({
    Some: Fn.T<RSome, Some<X>>;
    None: Fn.T<RNone, void>;
}))): RSome | RNone;
export declare function getExn<X>(option: T<X>, errorFactory?: () => Error): Some<X>;
