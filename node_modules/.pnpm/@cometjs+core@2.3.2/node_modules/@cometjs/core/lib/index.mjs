var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/common.ts
function callable(v) {
  if (typeof v !== "function") {
    throw new Error(`Expected a callable value, but got ${typeof v}`);
  }
  return v;
}
__name(callable, "callable");
function required(v) {
  if (v == null) {
    throw new Error(`Expected non nullable, but got ${typeof v}`);
  }
}
__name(required, "required");
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
var ident = /* @__PURE__ */ __name((x) => x, "ident");
function expectType(_) {
}
__name(expectType, "expectType");
function expectAssignable(_) {
}
__name(expectAssignable, "expectAssignable");
function expectEquals(..._) {
}
__name(expectEquals, "expectEquals");

// src/promise.ts
function timeout(ms) {
  return new Promise((resolve) => void setTimeout(resolve, ms));
}
__name(timeout, "timeout");
function defer() {
  let resolve = noop;
  let reject = noop;
  const deferred = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return Object.assign(deferred, { resolve, reject });
}
__name(defer, "defer");

// src/function.ts
var function_exports = {};
__export(function_exports, {
  range: () => range
});
function range(fn, ...arg) {
  if (typeof fn === "function") {
    return fn(...arg);
  }
  return fn;
}
__name(range, "range");

// src/option.ts
var option_exports = {};
__export(option_exports, {
  getExn: () => getExn,
  isNone: () => isNone,
  isSome: () => isSome,
  map: () => map,
  match: () => match,
  of: () => of,
  ofUnsafe: () => ofUnsafe,
  toString: () => toString
});
function of(x) {
  return range(x);
}
__name(of, "of");
function ofUnsafe(throwable) {
  try {
    return throwable();
  } catch {
    return null;
  }
}
__name(ofUnsafe, "ofUnsafe");
function isSome(option) {
  return option != null;
}
__name(isSome, "isSome");
function isNone(option) {
  return option == null;
}
__name(isNone, "isNone");
function toString(option) {
  return isSome(option) ? `Some(${typeof option})` : "None";
}
__name(toString, "toString");
function match(option) {
  return isSome(option) ? "Some" : "None";
}
__name(match, "match");
function map(option, fn) {
  if (typeof fn === "function") {
    return isSome(option) ? fn(option) : null;
  }
  if (typeof fn !== "object") {
    throw new Error(
      `The second argument only allows function or object but got: ${typeof fn}`
    );
  }
  const pattern = match(option);
  if (!(pattern in fn)) {
    throw new Error(
      `The object doesn't have bind to ${toString(option)} pattern`
    );
  }
  return range(fn[pattern], option);
}
__name(map, "map");
function getExn(option, errorFactory) {
  return map(option, {
    Some: (v) => v,
    None: () => {
      var _a;
      const error = (_a = errorFactory == null ? void 0 : errorFactory()) != null ? _a : new Error("You tried to get T of Option<T>, ut T is None");
      throw error;
    }
  });
}
__name(getExn, "getExn");

// src/condition.ts
var condition_exports = {};
__export(condition_exports, {
  isFalsy: () => isFalsy,
  isTruthy: () => isTruthy,
  map: () => map2,
  of: () => of2
});
function isTruthy(condition) {
  return !!condition;
}
__name(isTruthy, "isTruthy");
function isFalsy(condition) {
  return !condition;
}
__name(isFalsy, "isFalsy");
function of2(condition) {
  return condition;
}
__name(of2, "of");
function map2(condition, fn) {
  if (isTruthy(condition)) {
    return range(fn, condition);
  }
  return condition;
}
__name(map2, "map");

// src/tuple.ts
var tuple_exports = {};

// src/result.ts
var result_exports = {};
__export(result_exports, {
  err: () => err,
  getErrExn: () => getErrExn,
  getErrWithDefault: () => getErrWithDefault,
  getExn: () => getExn2,
  getWithDefault: () => getWithDefault,
  isErr: () => isErr,
  isOk: () => isOk,
  map: () => map3,
  match: () => match2,
  ofPromise: () => ofPromise,
  ofUnsafe: () => ofUnsafe2,
  ok: () => ok,
  toString: () => toString2
});
var s_ok = Symbol("ok");
var s_err = Symbol("err");
function ok(t) {
  return [s_ok, t];
}
__name(ok, "ok");
function err(t) {
  return [s_err, t];
}
__name(err, "err");
function ofUnsafe2(unsafe) {
  try {
    return ok(unsafe());
  } catch (e) {
    return err(e);
  }
}
__name(ofUnsafe2, "ofUnsafe");
async function ofPromise(promiseFn) {
  try {
    const result = await range(promiseFn);
    return ok(result);
  } catch (e) {
    return err(e);
  }
}
__name(ofPromise, "ofPromise");
function match2(result) {
  return isOk(result) ? "Ok" : "Err";
}
__name(match2, "match");
function toString2(result) {
  return `${match2(result)}(${typeof result})`;
}
__name(toString2, "toString");
function isOk(t) {
  return t[0] === s_ok;
}
__name(isOk, "isOk");
function isErr(t) {
  return t[0] === s_err;
}
__name(isErr, "isErr");
function getExn2(result) {
  if (isOk(result)) {
    return result[1];
  }
  throw new Error(`Expected Ok<T>, but got: ${toString2(result)}`);
}
__name(getExn2, "getExn");
function getWithDefault(result, defaultValue) {
  return isOk(result) ? result[1] : defaultValue;
}
__name(getWithDefault, "getWithDefault");
function getErrExn(result) {
  if (isErr(result)) {
    return result[1];
  }
  throw new Error(`Expected Err<T>, but got: ${toString2(result)}`);
}
__name(getErrExn, "getErrExn");
function getErrWithDefault(result, defaultValue) {
  return isErr(result) ? result[1] : defaultValue;
}
__name(getErrWithDefault, "getErrWithDefault");
function map3(result, fn) {
  if (typeof fn === "function") {
    return isOk(result) ? ok(fn(result[1])) : result;
  }
  if (typeof fn !== "object") {
    throw new Error(
      `The second argument only allows function or object but got: ${typeof fn}`
    );
  }
  const pattern = match2(result);
  if (!(pattern in fn)) {
    throw new Error(
      `The object doesn't have bind to ${pattern} pattern`
    );
  }
  return isOk(result) ? ok(range(fn.Ok, result[1])) : err(range(fn.Err, result[1]));
}
__name(map3, "map");

// src/json.ts
var json_exports = {};
export {
  condition_exports as Condition,
  function_exports as Fn,
  json_exports as JSON,
  option_exports as Option,
  result_exports as Result,
  tuple_exports as Tuple,
  callable,
  defer,
  expectAssignable,
  expectEquals,
  expectType,
  ident,
  noop,
  required,
  timeout
};
/*! For license information please see index.mjs.LEGAL.txt */
//# sourceMappingURL=index.mjs.map
